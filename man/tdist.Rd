% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tdist.R
\name{tdist}
\alias{tdist}
\title{Thresholded distances between rows of a matrix.}
\usage{
tdist(A, t, p = 10, filter = c("distributed", "local"),
  method = c("euclidean", "manhattan", "maximum"), rank = FALSE,
  dry_run = FALSE, max_iter = 4, columns = FALSE, restart, ...)
}
\arguments{
\item{A}{an m by n real-valued dense or sparse matrix}

\item{t}{a threshold distance value either in absolute distance (the default) or rank order (see \code{rank} below);
if missing an estimate derived from a 1-d SVD projection will be used}

\item{p}{projected subspace dimension}

\item{filter}{"local" filters candidate set sequentially,
"distributed" computes thresholded correlations in a parallel code section which can be
faster but requires that the data matrix is available (see notes).}

\item{method}{the distance measure to be used, one of
         "euclidean", or "manhattan".
Any unambiguous substring can be given.}

\item{rank}{when \code{TRUE}, the threshold \code{t} represents the top \code{t}
closest vectors, otherwise the threshold \code{t} specifies absolute distance; when
\code{rank=TRUE} then \code{t} must also be specified}

\item{dry_run}{set \code{TRUE} to return statistics and truncated SVD for tuning
\code{p} (see notes)}

\item{max_iter}{when \code{rank=TRUE}, a portion of the algorithm may iterate; this
number sets the maximum numer of such iterations}

\item{columns}{set to \code{TRUE} to compute distances between matrix columns instead
of rows, saving the expense of a matrix transpose (which can be significant if \code{A} is large)}

\item{restart}{either output from a previous run of \code{tdist} with \code{dry_run=TRUE},
or direct output from from \code{\link{irlba}} used to restart the \code{irlba}
algorithm when tuning \code{p} (see notes)}

\item{...}{additional arguments passed to \code{\link{irlba}}}
}
\value{
A list with elements:
\enumerate{
  \item \code{indices} A three-column matrix. The  first two columns contain
        indices of rows meeting the distance threshold \code{t},
        the third column contains the corresponding distance value (not returned
        when \code{dry_run=TRUE}).
  \item \code{restart} A truncated SVD returned by the IRLBA used to restart the
  algorithm (only returned when \code{dry_run=TRUE}).
  \item \code{n} The total number of _possible_ vectors that meet
    the correlation threshold identified by the algorithm.
  \item \code{longest_run} The largest number of successive entries in the
    ordered first singular vector within a projected distance defined by the
    correlation threshold; Equivalently, the number of \code{n * p} matrix
    vector products employed in the algorithm, not counting the truncated SVD step.
  \item \code{t} The threshold value.
  \item \code{svd_time} Time to compute truncated SVD.
  \item \code{total_time} Total run time.
}
}
\description{
Compute and return distances and indices of rows within a specified distance threshold
with respect to a specified distance metric. The algorithm works best for Euclidean
distance (the default option).
Alternatively compute the \code{t} closest rows when \code{rank=TRUE}. Or use
\code{columns=TRUE} to compute distances between columns instead, which is somewhat
cheaper for this algorithm than computing row distances.
Increase p to cut down the total number of candidate pairs evaluated,
at the expense of costlier truncated SVDs.
}
\note{
When \code{rank=TRUE} the method returns at least, and perhaps more than, the top \code{t} closest
indices and their distances, unless they could not be found within the iteration
limit \code{max_iter}.
}
\examples{
x <- matrix(rnorm(100*20), nrow=100)
# Find the top 10 closest vectors with respect to Euclidean distance:
td <- tdist(x, 10, rank=TRUE)
print(td$indices[1:10,])

# Compare with distances from `dist`:
d <- dist(x)
print(sort(d)[1:10])

}

